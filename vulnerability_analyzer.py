import os
import re
import chromadb
from chromadb.config import Settings
from sentence_transformers import SentenceTransformer
import ollama
import logging
from typing import List, Dict

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    def __init__(self, model_name: str = "codegemma:7b", persist_directory: str = "UJICOBARAG/knowledge_base"):
        self.model_name = model_name
        self.persist_directory = persist_directory
        
        # Verify Ollama
        self._verify_ollama()
        
        # Setup ChromaDB
        self.client = chromadb.PersistentClient(
            path=os.path.join(persist_directory, "chroma_db"),
            settings=Settings(anonymized_telemetry=False)
        )
        self.collection = self.client.get_or_create_collection("code_vulnerability")
        
        # Model embedding
        self.embedding_model = SentenceTransformer("all-MiniLM-L6-v2")
        
        # Verify collection
        count = self.collection.count()
        logger.info(f"ChromaDB collection contains {count} documents")
        if count == 0:
            logger.warning("ChromaDB collection is empty. Analysis may be inaccurate.")

    def _verify_ollama(self):
        """Verify connection to Ollama and model availability"""
        try:
            test_response = ollama.generate(
                model=self.model_name,
                prompt="test",
                stream=False
            )
            if not test_response.get('response'):
                raise RuntimeError("Ollama did not respond correctly")
            logger.info(f"Ollama connection verified with model {self.model_name}")
        except Exception as e:
            logger.error("\n" + "="*50)
            logger.error("ERROR: Failed to connect to Ollama")
            logger.error("Ensure:")
            logger.error("1. Run Ollama server in a separate terminal:")
            logger.error("   ollama serve")
            logger.error("2. Download the model first:")
            logger.error(f"   ollama pull {self.model_name}")
            logger.error("3. Verify model availability:")
            logger.error("   ollama list")
            logger.error("="*50 + "\n")
            raise

    def _generate_embeddings(self, text: str) -> List[float]:
        """Generate embedding for text"""
        return self.embedding_model.encode(text).tolist()

    def _build_prompt(self, code: str, context: List[Dict]) -> str:
        """Build a refined prompt with RAG context"""
        prompt = """[INST] You are a code security expert. Analyze the following code for vulnerabilities by comparing it to the provided reference examples from the knowledge base. Provide a precise and accurate analysis based on the context.

Reference Examples:
"""
        if not context:
            prompt += "No relevant examples found in the knowledge base.\n"
            logger.warning("No context retrieved from ChromaDB for the input code")
        else:
            for idx, item in enumerate(context):
                status = "VULNERABLE" if item['metadata']['label'] == "1" else "SECURE"
                prompt += f"\n{idx+1}. [{status}]\nCode: {item['document']}\n"

        prompt += f"""
Code to Analyze:
{code}

Instructions:
- If the code is secure (no vulnerabilities), set Status to 0, Vulnerability Type to "None", and provide an Analysis explaining why it is secure. The Recommendation should affirm the secure practice or suggest minor improvements if applicable.
- If the code is vulnerable, set Status to 1, specify the Vulnerability Type, and provide a detailed Analysis of the vulnerability and a Recommendation for fixing it.
- Do not report a vulnerability type or description for secure code.

Response Format:
Status: <0 for secure, 1 for vulnerable>
Vulnerability Type: <type of vulnerability or "None" for secure code>
Analysis: <detailed explanation of the vulnerability or why it's secure>
Recommendation: <specific suggestions for fixing the issue or maintaining security>
[/INST]"""
        
        logger.debug(f"Generated prompt:\n{prompt}")
        return prompt

    def analyze_code(self, code: str) -> Dict:
        """Analyze code for vulnerabilities"""
        if not code.strip():
            raise ValueError("Input code cannot be empty")
        
        # Get context from ChromaDB
        query_embedding = self._generate_embeddings(code)
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=5,
            include=["documents", "metadatas"]
        )
        
        # Format context
        context = []
        for doc, meta in zip(results['documents'][0], results['metadatas'][0]):
            context.append({
                "document": doc,
                "metadata": meta
            })
        logger.info(f"Queried ChromaDB for code, retrieved {len(context)} documents")
        
        # Build prompt
        prompt = self._build_prompt(code, context)
        
        # Query Ollama
        try:
            response = ollama.generate(
                model=self.model_name,
                prompt=prompt,
                stream=False,
                options={
                    "temperature": 0.2,
                    "num_predict": 768
                }
            )
            logger.info("Ollama response received")
        except Exception as e:
            logger.error(f"Ollama query failed: {str(e)}")
            raise
        
        # Parse response
        return self._parse_response(response['response'])

    def _parse_response(self, response: str) -> Dict:
        """Parse model output into structured data with validation"""
        result = {
            "status": 0,
            "type": "None",
            "analysis": "",
            "recommendation": "",
            "raw": response
        }
        
        # Extract information using regex
        status_match = re.search(r"Status:\s*([01])", response)
        type_match = re.search(r"Vulnerability Type:\s*(.+)", response)
        analysis_match = re.search(r"Analysis:\s*(.+?)(?=\nRecommendation:|\Z)", response, re.DOTALL)
        rec_match = re.search(r"Recommendation:\s*(.+)", response, re.DOTALL)
        
        if status_match:
            result["status"] = int(status_match.group(1))
        if type_match:
            result["type"] = type_match.group(1).strip()
        if analysis_match:
            result["analysis"] = analysis_match.group(1).strip()
        if rec_match:
            result["recommendation"] = rec_match.group(1).strip()
        
        # Validate response consistency
        if result["status"] == 0 and result["type"] != "None":
            logger.warning(f"Inconsistent response: Status is SECURE (0) but Vulnerability Type is {result['type']}. Forcing type to 'None'.")
            result["type"] = "None"
            result["analysis"] = result["analysis"] or "The code is secure with no identified vulnerabilities."
            result["recommendation"] = result["recommendation"] or "Continue using secure coding practices."
        elif result["status"] == 1 and result["type"] == "None":
            logger.warning("Inconsistent response: Status is VULNERABLE (1) but Vulnerability Type is None.")
        
        logger.info(f"Parsed response: Status={result['status']}, Type={result['type']}")
        return result

    def save_result(self, code: str, result: Dict, filename: str = "results.txt"):
        """Save analysis results to file"""
        os.makedirs(self.persist_directory, exist_ok=True)
        filepath = os.path.join(self.persist_directory, filename)
        
        with open(filepath, "a", encoding="utf-8") as f:
            f.write("\n" + "="*50 + "\n")
            f.write(f"Code:\n{code}\n\n")
            f.write(f"Status: {'VULNERABLE (1)' if result['status'] else 'SECURE (0)'}\n")
            f.write(f"Vulnerability Type: {result['type']}\n")
            f.write(f"Analysis:\n{result['analysis']}\n")
            f.write(f"Recommendation:\n{result['recommendation']}\n")
            f.write("="*50 + "\n")
        logger.info(f"Saved results to {filepath}")

def get_user_code_input() -> str:
    """Get multi-line code input from user"""
    print("\nEnter the code to analyze (press Enter twice to submit):")
    lines = []
    while True:
        line = input()
        if line == "" and len(lines) > 0:
            break
        if line != "":
            lines.append(line)
    return "\n".join(lines)

def main():
    print("""
    ====================================
     CODE VULNERABILITY ANALYZER (CodeGemma)
    ====================================
    """)
    
    # Initialize analyzer
    try:
        analyzer = VulnerabilityAnalyzer(persist_directory="UJICOBARAG/knowledge_base")
    except Exception as e:
        logger.error(f"Failed to initialize analyzer: {e}")
        print(f"Failed to initialize analyzer: {e}")
        return
    
    # Test retrieval to verify knowledge base connection
    test_code = "db.query(f\"SELECT * FROM users WHERE id = {user_input}\")"
    print("\nTesting RAG retrieval with sample code...")
    query_embedding = analyzer._generate_embeddings(test_code)
    results = analyzer.collection.query(
        query_embeddings=[query_embedding],
        n_results=5,
        include=["documents", "metadatas"]
    )
    context = [
        {"document": doc, "metadata": meta}
        for doc, meta in zip(results['documents'][0], results['metadatas'][0])
    ]
    if context:
        print("RAG Retrieval Test Successful. Retrieved documents:")
        for idx, item in enumerate(context):
            print(f"{idx+1}. {item['document']}")
    else:
        print("RAG Retrieval Test Failed. Check ChromaDB collection content.")
    
    # Main loop
    while True:
        try:
            code = get_user_code_input()
            if not code.strip():
                print("Exiting...")
                break
            print("\nAnalyzing code...")
            result = analyzer.analyze_code(code)
            print("\n=== ANALYSIS RESULTS ===")
            print(f"Status: {'VULNERABLE (1)' if result['status'] else 'SECURE (0)'}")
            print(f"Vulnerability Type: {result['type']}")
            print(f"\nAnalysis:\n{result['analysis']}")
            print(f"\nRecommendation:\n{result['recommendation']}")
            analyzer.save_result(code, result)
        except ValueError as ve:
            logger.error(f"Input Error: {str(ve)}")
            print(f"\nInput Error: {str(ve)}")
            continue
        except KeyboardInterrupt:
            print("\nExiting...")
            break
        except Exception as e:
            logger.error(f"Error: {str(e)}")
            print(f"\nError: {str(e)}")
            continue

if __name__ == "__main__":
    main()